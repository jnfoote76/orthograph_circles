defmodule WordChunkCircles do
  @moduledoc """
  Documentation for WordChunkCircles.
  """

  # Returns all valid circles given a set of word chunks and a map containing
  # all valid words in a language as keys (should each be given in all-caps)
  def solve(word_chunks, word_map) do
    # Capitalizes word chunks and
    [first | others] = word_chunks
    |> Enum.map(fn elem -> String.upcase(elem) end)
    |> Enum.sort()

    solve_help([first], others, word_map, [])
  end

  # solve_help is the recurrence representing the problem solution, given 
  # an existing start of a solution, a list of word chunks not used in the 
  # current solution, a word map, and a list of full solutions that have already been found

  # The base case is where there are no more word chunks (and therefore no possible branches)
  defp solve_help(curr_sol_reversed, [], word_map, already_found_sols) do 
    [curr_word_start | _] = curr_sol_reversed
    [sol_beginning | rest_of_solution] = Enum.reverse(curr_sol_reversed)

    # Still need to check if the solution end connects back to the beginning
    cond do
      Map.has_key?(word_map, curr_word_start <> sol_beginning) ->
        [[sol_beginning | rest_of_solution] | already_found_sols]
      true ->
        already_found_sols
    end
  end

  defp solve_help(curr_sol_reversed, remaining_word_chunks, word_map, already_found_sols) do
    [curr_word_start | _] = curr_sol_reversed
    
    # If there are no valid pairs given the current solution and remaining
    # chunks, then the current path is invalid
    # Otherwise, we need to explore the branches generated by each of the pairs
    case valid_pairs(curr_word_start, remaining_word_chunks, word_map) do
      [] -> already_found_sols
      curr_valid_pairs ->
        List.foldr(curr_valid_pairs, already_found_sols, fn (elem, acc) ->
          without_elem = List.delete(remaining_word_chunks, elem)
          solve_help([elem | curr_sol_reversed], without_elem, word_map, acc) 
        end)
    end
  end

  # Returns a list of all chunks from remaining_word_chunks param that end a valid
  # word started by start param
  defp valid_pairs(start, remaining_word_chunks, word_map) do
    List.foldr(remaining_word_chunks, [], fn (elem, acc) ->
      cond do
        Map.has_key?(word_map, start <> elem) -> [elem | acc]
        true -> acc
      end
    end)
  end
end
